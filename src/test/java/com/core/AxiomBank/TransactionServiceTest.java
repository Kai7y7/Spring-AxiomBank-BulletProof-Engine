package com.core.AxiomBank;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import java.math.BigDecimal;
import java.util.Optional;

import com.core.AxiomBank.Dtos.SetAmountReq;
import com.core.AxiomBank.Dtos.TransactionResp;
import com.core.AxiomBank.Entities.*;
import com.core.AxiomBank.Exceptions.BadRequestException;
import com.core.AxiomBank.Exceptions.ForbiddenActionException;
import com.core.AxiomBank.Redis.RateLimitingService;
import com.core.AxiomBank.Repositories.AccountRepository;
import com.core.AxiomBank.Repositories.LedgerEntryRepository;
import com.core.AxiomBank.Repositories.Mappers;
import com.core.AxiomBank.Repositories.TransactionRepository;
import com.core.AxiomBank.Services.TransactionService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

/**
 * Generated using Gemini 3 pro and manually verified for business logic accuracy.
 * This is single file in entire project generated by ai, in all others I suffered myself
 */


@ExtendWith(MockitoExtension.class)
class TransactionServiceTest {

    @Mock private AccountRepository accountRepository;
    @Mock private TransactionRepository transactionRepository;
    @Mock private LedgerEntryRepository ledgerEntryRepository;
    @Mock private RateLimitingService rateLimitingService;
    @Mock private Mappers mappers;

    @Mock private TransactionService selfProxy; // The magical proxy

    @InjectMocks
    private TransactionService transactionService;

    // Test Data
    private Account richAccount;
    private Account brokeAccount;
    private Client owner;
    private Client thief;
    private Transaction pendingTx;

    @BeforeEach
    void setup() {
        ReflectionTestUtils.setField(transactionService, "self", selfProxy);

        owner = new Client();
        owner.setId(1L);

        thief = new Client();
        thief.setId(666L);

        richAccount = new Account();
        richAccount.setId(100L);
        richAccount.setOwner(owner);
        richAccount.setBalance(new BigDecimal("50000.00"));
        richAccount.setCurrency(Currency.USD);
        richAccount.setStatus(AccountStatus.ACTIVE);

        brokeAccount = new Account();
        brokeAccount.setId(200L);
        brokeAccount.setOwner(thief);
        brokeAccount.setBalance(new BigDecimal("5.00"));
        brokeAccount.setCurrency(Currency.USD);
        brokeAccount.setStatus(AccountStatus.ACTIVE);

        pendingTx = new Transaction();
        pendingTx.setId(555L);
        pendingTx.setStatus(TransactionStatus.PENDING);
    }

    // =========================================================================
    // ORCHESTRATION TESTS (Does the Service call the Transactional methods?)
    // =========================================================================

    @Test
    @DisplayName("ORCHESTRATION: Deposit Flow - Init -> Process -> Finalize")
    void testDeposit_Orchestration() {
        SetAmountReq req = new SetAmountReq(new BigDecimal("100.00"));

        // 1. Mock the 'Init' call
        when(selfProxy.initTransaction(eq(TransactionType.DEPOSIT), any(), eq(100L), isNull()))
                .thenReturn(pendingTx);

        // 2. Mock the 'Finalize' call
        TransactionResp expectedResp = new TransactionResp();
        when(selfProxy.finalizeTransaction(555L, TransactionStatus.COMPLETED))
                .thenReturn(expectedResp);

        // Act
        TransactionResp result = transactionService.depositTransaction(100L, req, 1L);

        // Assert
        verify(rateLimitingService).checkTransactionFrequency(1L);
        verify(selfProxy).initTransaction(eq(TransactionType.DEPOSIT), any(), eq(100L), isNull());
        verify(selfProxy).processDeposit(555L, 100L, req.getAmount()); // The heavy lifting
        verify(selfProxy).finalizeTransaction(555L, TransactionStatus.COMPLETED);

        assertThat(result).isEqualTo(expectedResp);
    }

    @Test
    @DisplayName("ORCHESTRATION: Failure Handling - When logic explodes, audit must survive")
    void testDeposit_Orchestration_Failure() {
        SetAmountReq req = new SetAmountReq(new BigDecimal("100.00"));

        when(selfProxy.initTransaction(any(), any(), any(), any())).thenReturn(pendingTx);

        // Simulate explosion in business logic
        doThrow(new RuntimeException("Database is drunk"))
                .when(selfProxy).processDeposit(any(), any(), any());

        // Act & Assert
        assertThatThrownBy(() -> transactionService.depositTransaction(100L, req, 1L))
                .isInstanceOf(RuntimeException.class)
                .hasMessage("Database is drunk");

        // Verify the mop-up crew was called
        verify(selfProxy).markTransactionFailed(555L, "Database is drunk");
    }

    // =========================================================================
    // LOGIC TESTS (Testing the actual math inside process methods)
    // =========================================================================

    @Test
    @DisplayName("LOGIC: Process Deposit - Takes money and steals 3% fee like a proper bank")
    void testProcessDeposit_Logic() {

        BigDecimal amount = new BigDecimal("100.00");

        when(accountRepository.findByIdWithLock(100L)).thenReturn(Optional.of(richAccount));
        when(transactionRepository.getReferenceById(555L)).thenReturn(pendingTx);

        // Act - Call the method directly (simulating what the proxy does)
        transactionService.processDeposit(555L, 100L, amount);

        // Assert - Math Check
        // 50,000 + (100 - 3% fee) = 50,000 + 97 = 50,097
        assertThat(richAccount.getBalance()).isEqualByComparingTo(new BigDecimal("50097.00"));

        // Verify Fee and Ledger
        verify(transactionRepository).save(argThat(tx ->
                tx.getTransactionType() == TransactionType.FEE &&
                        tx.getAmount().compareTo(new BigDecimal("3.00")) == 0
        ));

        verify(ledgerEntryRepository, times(2)).save(any(LedgerEntry.class)); // 1 Deposit, 1 Fee
    }

    @Test
    @DisplayName("LOGIC: Process Withdraw - Happy Path")
    void testProcessWithdraw_Logic() {
        BigDecimal amount = new BigDecimal("100.00");

        when(accountRepository.findByIdWithLock(100L)).thenReturn(Optional.of(richAccount));
        when(transactionRepository.getReferenceById(555L)).thenReturn(pendingTx);

        // Act
        transactionService.processWithdrawal(555L, 1L, 100L, amount);

        // Assert
        // 50,000 - 100 (amount) - 3 (fee) = 49,897
        assertThat(richAccount.getBalance()).isEqualByComparingTo(new BigDecimal("49897.00"));
    }

    @Test
    @DisplayName("LOGIC: Security - Stranger Danger (Withdraw)")
    void testProcessWithdraw_SecurityViolation() {
        BigDecimal amount = new BigDecimal("10.00");
        when(accountRepository.findByIdWithLock(100L)).thenReturn(Optional.of(richAccount));

        // Thief (666) tries to access Owner (1)
        assertThatThrownBy(() -> transactionService.processWithdrawal(555L, 666L, 100L, amount))
                .isInstanceOf(ForbiddenActionException.class)
                .hasMessage("Access denied.");

        // Ensure balance wasn't touched
        assertThat(richAccount.getBalance()).isEqualByComparingTo(new BigDecimal("50000.00"));
    }

    @Test
    @DisplayName("LOGIC: Transfer - Deadlock Prevention Order")
    void testProcessTransfer_LockingOrder() {
        // To prevent deadlocks, we must lock smaller ID first.
        // Transfer from 200 (Broke) to 100 (Rich)
        // Order must be: Lock 100, then Lock 200.

        Account from = brokeAccount; // ID 200
        Account to = richAccount;    // ID 100
        BigDecimal amount = new BigDecimal("1.00");

        when(accountRepository.findByIdWithLock(100L)).thenReturn(Optional.of(to));
        when(accountRepository.findByIdWithLock(200L)).thenReturn(Optional.of(from));
        when(transactionRepository.getReferenceById(555L)).thenReturn(pendingTx);

        // Act
        transactionService.processTransfer(555L, 666L, 200L, 100L, amount);

        verify(accountRepository).findByIdWithLock(100L);
        verify(accountRepository).findByIdWithLock(200L);
    }

    // =========================================================================
    // VALIDATION TESTS (Fast fail checks)
    // =========================================================================

    @ParameterizedTest
    @ValueSource(strings = {"0.00", "-10.00", "-0.01"})
    @DisplayName("VALIDATION: Amount - Garbage in, Exception out")
    void testValidation_InvalidAmount(String amountStr) {
        SetAmountReq req = new SetAmountReq(new BigDecimal(amountStr));

        assertThatThrownBy(() -> transactionService.depositTransaction(100L, req, 1L))
                .isInstanceOf(BadRequestException.class)
                .hasMessage("Amount must be positive.");

        verifyNoInteractions(selfProxy); // Shouldn't even start a transaction
    }

    @Test
    @DisplayName("VALIDATION: Transfer to Self - Recursion is for nerds, not banks")
    void testTransfer_ToSameAccount() {
        SetAmountReq req = new SetAmountReq(new BigDecimal("10.00"));

        assertThatThrownBy(() -> transactionService.transferTransaction(100L, 1L, 100L, req))
                .isInstanceOf(BadRequestException.class)
                .hasMessage("Cannot transfer to same account.");
    }

    @Test
    @DisplayName("VALIDATION: Limit Exceeded - Money Laundering Check")
    void testProcessDeposit_LimitExceeded() {
        // This is a LOGIC test, so we call processDeposit
        when(accountRepository.findByIdWithLock(100L)).thenReturn(Optional.of(richAccount));

        BigDecimal hugeAmount = new BigDecimal("10001.00"); // USD Limit is 10k

        assertThatThrownBy(() -> transactionService.processDeposit(555L, 100L, hugeAmount))
                .isInstanceOf(BadRequestException.class)
                .hasMessageContaining("Amount exceeds limit");
    }

    // =========================================================================
    // HELPER TESTS
    // =========================================================================

    @Test
    @DisplayName("HELPER: Mark Failed - The autopsy")
    void testMarkTransactionFailed() {
        Transaction tx = new Transaction();
        tx.setStatus(TransactionStatus.PENDING);

        when(transactionRepository.findById(555L)).thenReturn(Optional.of(tx));

        // Act
        transactionService.markTransactionFailed(555L, "Oops");

        // Assert
        assertThat(tx.getStatus()).isEqualTo(TransactionStatus.FAILED);
        verify(transactionRepository).save(tx);
    }
}